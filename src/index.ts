import { app, BrowserWindow, dialog, ipcMain } from 'electron';
import { promises as fs } from "fs";
import YAML from "yaml";
import * as path from "path";
import { SSHConnection } from "node-ssh-forward";
import SSHConfig from "ssh-config";
import { getFileContent } from "./util/getFileContent";
// This allows TypeScript to pick up the magic constant that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
    // eslint-disable-line global-require
    app.quit();
}

const createWindow = (): void => {
    // Create the browser window.
    const mainWindow = new BrowserWindow({
        height: 600,
        width: 800,
        webPreferences: {
            preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY
        }
    });

    // and load the index.html of the app.
    mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

    // Open the DevTools.
    if (process.env.NODE_ENV === 'development') {
        mainWindow.webContents.openDevTools();
    }

    ipcMain.handle('openDockerComposeConfig', async (e, dir: string | undefined) => {
        const ret = await dialog.showOpenDialog(mainWindow, {
            defaultPath: dir,
            filters: [{extensions: ['yml', 'yaml'], name: '*'}],
            properties: ['openFile']
        });
        const filePath = ret.filePaths[0];
        if (filePath == null) return Promise.reject();
        const content = YAML.parse(await fs.readFile(ret.filePaths[0], 'utf-8'));
        const p = path.parse(path.relative(path.resolve(filePath, '../../'), filePath));
        const mappings = Object.entries(content.services).map(([key, service]: [string, any]) => {
            const ports = service.ports.map((port: string) => {
                const values = port.split(':').map((v: string) => parseInt(v));
                return {localPort: values[0], remotePort: values[1]};
            });
            return {service: key, ports};
        });
        return {name: p.dir, mappings};
    });

    const conns: { id: string, conn: SSHConnection }[] = [];
    ipcMain.on('connect', async (e, item: ConnectionItem) => {
        e.sender.send('connectionChange', {id: item.id, state: 'pending'});
        try {
            const sshConfig = SSHConfig.parse(await getFileContent('~/.ssh/config'));
            const config = sshConfig.compute(item.remoteAddr);
            const privateKey = await getFileContent((config.IdentityFile || ['~/.ssh/id_rsa'])[0]);
            const tunnels = item.ports.map(async p => {
                const conn = config != null ?
                    new SSHConnection({
                        username: config.User,
                        privateKey: privateKey,
                        endHost: config.HostName,
                        endPort: config.Port != null ? parseInt(config.Port) : 22,
                    }) :
                    new SSHConnection({
                        endHost: item.remoteAddr
                    });
                conns.push({id: item.id, conn});
                return await conn.forward({
                    fromPort: p.localPort,
                    toPort: p.remotePort
                });
            });
            await Promise.all(tunnels);
            e.sender.send('connectionChange', {id: item.id, state: 'active'});
        } catch (e) {
            e.sender.send('connectionChange', {id: item.id, state: 'inactive'}, e.message);
        }
    });

    ipcMain.on('disconnect', async (e, item: ConnectionItem) => {
        e.sender.send('connectionChange', {id: item.id, state: 'pending'});
        for await (const c1 of conns.filter(c => c.id === item.id)) {
            await c1.conn.shutdown();
            conns.slice(conns.indexOf(c1), 1);
        }
        e.sender.send('connectionChange', {id: item.id, state: 'inactive'});
    });
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
    if (process.platform !== 'darwin') {
        app.quit();
    }
});

app.on('activate', () => {
    // On OS X it's common to re-create a window in the app when the
    // dock icon is clicked and there are no other windows open.
    if (BrowserWindow.getAllWindows().length === 0) {
        createWindow();
    }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
